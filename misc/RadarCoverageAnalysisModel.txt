"""
Overview:
    This simulation tool computes radar coverage by evaluating the received power over a range of distances, factoring in
    atmospheric refractive effects. It then visualizes the coverage area, highlighting regions where the radar can
    effectively detect targets.

    Atmospheric Refraction Modeling: The provided code uses a simplified model for atmospheric refraction by adjusting the
    path loss exponent based on a refractivity gradient. For more accurate modeling, consider integrating detailed
    refractivity profiles and employing numerical methods like the Parabolic Equation (PE) method.
"""

import numpy as np
import matplotlib.pyplot as plt
from mpl_toolkits.mplot3d import Axes3D


class RadarSystem:
    """Class to manage radar system parameters and calculations."""

    def __init__(self):
        # Radar System Parameters
        self._transmit_power = 1e6  # Transmit power in watts (1 MW), represents the radar's output power
        self._transmit_gain = 30  # Transmit antenna gain (linear scale), amplifies the transmitted signal
        self._receive_gain = 30  # Receive antenna gain (linear scale), amplifies the received signal
        self._frequency = 10e6  # Operating frequency in Hz (10 MHz), determines the radar's wavelength
        self._rcs = 1  # Radar Cross Section in m^2, measures target's reflectivity
        self._min_detectable_signal = 1e-13  # Minimum Detectable Signal in watts, threshold for target detection
        self._speed_of_light = 3e8  # Speed of light in m/s, used to calculate wavelength
        self._wavelength = self._speed_of_light / self._frequency  # Wavelength in meters, affects signal propagation

    # Properties for read-only access to radar parameters
    @property
    def transmit_power(self):
        return self._transmit_power

    @property
    def transmit_gain(self):
        return self._transmit_gain

    @property
    def receive_gain(self):
        return self._receive_gain

    @property
    def wavelength(self):
        return self._wavelength

    @property
    def rcs(self):
        return self._rcs

    @property
    def min_detectable_signal(self):
        return self._min_detectable_signal


class AtmosphericModel:
    """Class to handle atmospheric refraction calculations."""

    def __init__(self, refractivity_gradient=-39e-6):
        # Refractivity gradient per meter, models how atmosphere bends radio waves
        # Negative value indicates standard atmosphere where refractivity decreases with height
        self.refractivity_gradient = refractivity_gradient

    def calculate_path_loss_exponent(self, distance):
        """Calculate path loss exponent considering atmospheric refraction.

        Args:
            distance: Array of distances in meters
        Returns:
            Adjusted path loss exponent, accounting for atmospheric effects
        """
        # Base path loss exponent is 4 (standard free-space path loss)
        # Adjust based on refractivity gradient * distance to model atmospheric effects
        # This is a simplified model; real-world applications might use ray tracing or parabolic equation methods
        path_loss = 4 + self.refractivity_gradient * distance
        # Clip values to ensure realistic path loss (between 2 and 6)
        # 2 represents free-space conditions, 6 accounts for severe atmospheric effects
        return np.clip(path_loss, 2, 6)


class RadarCoverageCalculator:
    """Class to compute radar coverage and received power."""

    def __init__(self, radar_system, atmospheric_model, distance_range):
        # Initialize with radar system, atmospheric model, and distance array
        self.radar = radar_system  # Radar system parameters
        self.atmosphere = atmospheric_model  # Atmospheric model for refraction
        self.distances = distance_range  # Array of distances for analysis (1 km to 3000 km)
        self.pi = np.pi  # Mathematical constant for calculations

    def calculate_received_power(self):
        """Calculate received power using the adjusted radar equation.

        Returns:
            Array of received power values for each distance
        """
        # Calculate path loss exponent considering atmospheric refraction
        path_loss_exponent = self.atmosphere.calculate_path_loss_exponent(self.distances)

        # Radar equation: Pr = (Pt * Gt * Gr * λ^2 * RCS) / ((4π)^3 * R^path_loss_exponent)
        # Pt: Transmit power
        # Gt, Gr: Transmit and receive antenna gains
        # λ: Wavelength
        # RCS: Radar Cross Section
        # R: Distance to target
        # Path loss exponent is adjusted for atmospheric effects
        power = (self.radar.transmit_power * self.radar.transmit_gain *
                 self.radar.receive_gain * self.radar.wavelength ** 2 * self.radar.rcs) / \
                ((4 * self.pi) ** 3 * self.distances ** path_loss_exponent)
        return power

    def get_max_range(self, received_power):
        """Calculate maximum detection range where received power >= minimum detectable signal.

        Args:
            received_power: Array of received power values
        Returns:
            Maximum range in meters where detection is possible
        """
        # Find indices where received power exceeds or equals the minimum detectable signal
        max_range_index = np.where(received_power >= self.radar.min_detectable_signal)[-1]
        # Return the maximum range if detection is possible, else return 0
        return self.distances[max_range_index[-1]] if len(max_range_index) > 0 else 0


class RadarVisualizer:
    """Class to handle visualization of radar coverage."""

    def __init__(self, calculator):
        self.calculator = calculator  # Calculator object for accessing radar data

    def plot_power_vs_distance(self):
        """Create 2D plot of received power vs distance."""
        # Calculate received power for all distances
        received_power = self.calculator.calculate_received_power()
        # Convert to decibels for better visualization
        power_dB = 10 * np.log10(received_power)
        mds_dB = 10 * np.log10(self.calculator.radar.min_detectable_signal)

        # Create a 2D line plot
        plt.figure(figsize=(10, 6))
        plt.plot(self.calculator.distances / 1e3, power_dB, label='Received Power')
        # Add horizontal line for minimum detectable signal threshold
        plt.axhline(y=mds_dB, color='r', linestyle='--', label='Minimum Detectable Signal')
        plt.title('Radar Received Power vs. Distance with Atmospheric Refraction')
        plt.xlabel('Distance (km)')
        plt.ylabel('Received Power (dB)')
        plt.grid(True)
        plt.legend()
        plt.tight_layout()
        plt.show()

    def plot_3d_coverage(self):
        """Create 3D plot of radar coverage area."""
        # Calculate received power and maximum detection range
        received_power = self.calculator.calculate_received_power()
        max_range = self.calculator.get_max_range(received_power)

        # Create meshgrid for azimuth (0 to 360°) and elevation (0 to 90°)
        # These represent the angular coordinates for the radar's coverage volume
        azimuth = np.linspace(0, 2 * np.pi, 360)
        elevation = np.linspace(0, np.pi / 2, 90)
        azimuth, elevation = np.meshgrid(azimuth, elevation)

        # Convert spherical coordinates to Cartesian for 3D visualization
        # Assumes the radar coverage forms a hemisphere with radius = max_range
        x = max_range * np.sin(elevation) * np.cos(azimuth)
        y = max_range * np.sin(elevation) * np.sin(azimuth)
        z = max_range * np.cos(elevation)

        # Create 3D plot of the coverage volume
        fig = plt.figure(figsize=(10, 8))
        ax = fig.add_subplot(111, projection='3d')
        ax.plot_surface(x / 1e3, y / 1e3, z / 1e3, color='cyan', alpha=0.5)
        ax.set_title('Radar Coverage Area (3D) with Atmospheric Refraction')
        ax.set_xlabel('X (km)')
        ax.set_ylabel('Y (km)')
        ax.set_zlabel('Altitude (km)')
        plt.tight_layout()
        plt.show()


def main():
    """Main function to orchestrate the radar coverage simulation."""
    # Initialize radar system with default parameters
    radar = RadarSystem()
    # Initialize atmospheric model with standard refractivity gradient
    atmosphere = AtmosphericModel()
    # Define distance range for analysis (1 km to 3000 km)
    distances = np.linspace(1e3, 3e6, 1000)
    # Create calculator to compute coverage metrics
    calculator = RadarCoverageCalculator(radar, atmosphere, distances)
    # Create visualizer to generate plots
    visualizer = RadarVisualizer(calculator)

    # Generate visualizations: 2D power plot and 3D coverage plot
    visualizer.plot_power_vs_distance()
    visualizer.plot_3d_coverage()


if __name__ == "__main__":
    main()